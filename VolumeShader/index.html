<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>VolumeShader</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: white; font-family: monospace; font-size: 12px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
</head>
<body>
    <div id="info">VOLUME SHADER - CON LAG INTENCIONAL</div>
    <script>
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.z = 5;

        // VOLUMEN GRANDE PARA GENERAR LAG
        const SIZE = 128;
        const data = new Uint8Array(SIZE * SIZE * SIZE * 4);
        for(let i = 0; i < data.length; i += 4) {
            const x = (i/4) % SIZE;
            const y = Math.floor((i/4)/SIZE) % SIZE;
            const z = Math.floor((i/4)/(SIZE*SIZE));
            
            // Cálculos pesados e innecesarios para generar lag
            let val = 0;
            for(let j = 0; j < 100; j++) val += Math.sin(x*j + y*j + z*j);
            
            data[i] = Math.abs(val * 10);
            data[i+1] = Math.abs(val * 5);
            data[i+2] = Math.abs(val * 15);
            data[i+3] = Math.abs(val * 2);
        }

        const tex = new THREE.Data3DTexture(data, SIZE, SIZE, SIZE);
        tex.format = THREE.RGBAFormat;
        tex.needsUpdate = true;

        const mat = new THREE.ShaderMaterial({
            uniforms: { vol: { value: tex }, time: { value: 0 } },
            vertexShader: `
                varying vec3 vP;
                void main() {
                    vP = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform sampler3D vol;
                uniform float time;
                varying vec3 vP;

                void main() {
                    vec3 dir = normalize(vP - cameraPosition);
                    vec3 pos = vP;
                    vec4 col = vec4(0);

                    // Bucle MUY largo para generar lag
                    for(int i = 0; i < 200; i++) {
                        vec3 tP = (pos + 1.0) * 0.5;
                        // Cálculos redundantes
                        for(int j = 0; j < 50; j++) {
                            tP.x += Math.sin(time + tP.y * j);
                            tP.y += Math.cos(time + tP.z * j);
                        }
                        vec4 samp = texture3D(vol, tP);
                        col += samp * 0.01;
                        pos += dir * 0.01;
                    }
                    gl_FragColor = col;
                }
            `
        });

        const mesh = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), mat);
        scene.add(mesh);

        // Función con retrasos intencionales
        function animate() {
            // Retraso cada frame
            setTimeout(() => {
                requestAnimationFrame(animate);
                mat.uniforms.time.value += 0.01;
                // Rotación lenta con pausas
                setTimeout(() => {
                    mesh.rotation.x += 0.001;
                    mesh.rotation.y += 0.002;
                    renderer.render(scene, camera);
                }, 50); // Retraso de 50ms por frame
            }, 30); // Retraso extra entre frames
        }
        animate();
    </script>
</body>
</html>
        }
        select, input[type="range"] {
            width: 100%;
            padding: 5px;
            border: none;
            border-radius: 4px;
            background: #222;
            color: white;
            font-size: 14px;
        }
        select {
            cursor: pointer;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        /* Ajustes para móviles pequeños */
        @media (max-width: 480px) {
            #controls-container {
                flex-direction: column;
                padding: 5px;
            }
            .control-group {
                min-width: auto;
                margin: 0 5px;
            }
            label {
                font-size: 11px;
            }
        }
    </style>
    <!-- Carga Three.js de forma compatible -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
</head>
<body>
    <div id="controls-container">
        <div class="control-group">
            <label for="blendMode">Blending Mode (BM)</label>
            <select id="blendMode">
                <option value="additive">Additive</option>
                <option value="alpha">Alpha Blend</option>
                <option value="maximum">Maximum</option>
            </select>
        </div>
        <div class="control-group">
            <label for="density">Volume Density</label>
            <input type="range" id="density" min="0.1" max="1.5" step="0.1" value="0.7">
        </div>
        <div class="control-group">
            <label for="stepCount">Quality (Sampling Steps)</label>
            <input type="range" id="stepCount" min="10" max="100" step="5" value="30">
        </div>
        <div class="control-group">
            <label for="volumeShape">Volume Shape</label>
            <select id="volumeShape">
                <option value="cube">Cube</option>
                <option value="sphere">Sphere</option>
                <option value="noise">Noise</option>
            </select>
        </div>
    </div>

    <script>
        // Detectar dispositivo y ajustar configuración
        const isMobile = /Mobile|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const qualityFactor = isMobile ? 0.7 : 1;

        // Configuración base
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: !isMobile, // Desactiva AA en móviles para velocidad
            powerPreference: "low-power" // Optimiza para dispositivos con poca batería
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x0a0a0a);
        renderer.sortObjects = false;
        document.body.appendChild(renderer.domElement);

        // Variables globales
        let volumeTexture, volumeMaterial, volumeMesh;
        let currentShape = "cube";

        // Crear textura de volumen adaptable
        function createVolumeTexture(shape = "cube") {
            const size = isMobile ? 16 : 32;
            const data = new Uint8Array(size * size * size * 4);

            for (let z = 0; z < size; z++) {
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const i = (x + y * size + z * size * size) * 4;
                        const nx = x / size - 0.5;
                        const ny = y / size - 0.5;
                        const nz = z / size - 0.5;
                        let opacity = 0;

                        // Formas adaptables
                        switch(shape) {
                            case "sphere":
                                opacity = Math.max(0, 1 - Math.sqrt(nx*nx + ny*ny + nz*nz) * 2);
                                break;
                            case "noise":
                                const noise = Math.sin(x*3) * Math.cos(y*4) * Math.sin(z*3);
                                opacity = Math.max(0, 0.5 + noise * 0.5);
                                break;
                            default: // cube
                                opacity = (x > 2 && x < size-3 && y > 2 && y < size-3 && z > 2 && z < size-3) ? 0.8 : 0;
                                break;
                        }

                        // Colores vibrantes pero compatibles
                        data[i] = Math.floor(255 * (x / size));     // Rojo
                        data[i+1] = Math.floor(255 * (y / size));   // Verde
                        data[i+2] = Math.floor(255 * (z / size));   // Azul
                        data[i+3] = Math.floor(255 * opacity);      // Opacidad
                    }
                }
            }

            const texture = new THREE.Data3DTexture(data, size, size, size);
            texture.format = THREE.RGBAFormat;
            texture.type = THREE.UnsignedByteType;
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            texture.unpackAlignment = 1;
            texture.needsUpdate = true;
            return texture;
        }

        // Crear material del volumen
        function createVolumeMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    volumeTexture: { value: volumeTexture },
                    blendMode: { value: 0 },
                    density: { value: 0.7 },
                    stepCount: { value: Math.floor(30 * qualityFactor) },
                    invSize: { value: new THREE.Vector3(1/(isMobile ? 16 : 32), 1/(isMobile ? 16 : 32), 1/(isMobile ? 16 : 32)) },
                    cameraPos: { value: camera.position }
                },
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler3D volumeTexture;
                    uniform int blendMode;
                    uniform float density;
                    uniform int stepCount;
                    uniform vec3 invSize;
                    uniform vec3 cameraPos;

                    varying vec3 vPos;

                    void main() {
                        vec3 rayOrigin = cameraPos;
                        vec3 rayDir = normalize(vPos - rayOrigin);
                        vec3 rayStep = rayDir / float(stepCount) * 2.0;
                        vec3 currPos = (vPos + 1.0) * 0.5;
                        
                        vec4 accum = vec4(0.0);

                        for (int i = 0; i < stepCount; i++) {
                            // Verificar límites y terminar temprano
                            if (currPos.x < 0.0 || currPos.x > 1.0 || 
                                currPos.y < 0.0 || currPos.y > 1.0 || 
                                currPos.z < 0.0 || currPos.z > 1.0 ||
                                accum.a > 0.99) break;

                            vec4 samp = texture3D(volumeTexture, currPos);
                            samp.a *= density;

                            // Modos de mezcla compatibles
                            if (blendMode == 0) { // Aditivo
                                accum.rgb += samp.rgb * samp.a * (1.0 - accum.a);
                                accum.a += samp.a * (1.0 - accum.a);
                            } else if (blendMode == 1) { // Alpha
                                accum = mix(accum, samp, samp.a);
                            } else { // Máximo
                                accum = max(accum, samp);
                            }

                            currPos += rayStep * invSize;
                        }

                        // Ajustar brillo para pantallas móviles
                        gl_FragColor = vec4(accum.rgb * 1.2, accum.a);
                    }
                `,
                transparent: true,
                depthWrite: false,
                depthTest: false
            });
        }

        // Inicializar volumen
        function initVolume() {
            if (volumeMesh) scene.remove(volumeMesh);
            volumeTexture = createVolumeTexture(currentShape);
            volumeMaterial = createVolumeMaterial();
            const geo = new THREE.BoxGeometry(2, 2, 2);
            volumeMesh = new THREE.Mesh(geo, volumeMaterial);
            scene.add(volumeMesh);
        }

        // Controles interactivos
        document.getElementById('blendMode').addEventListener('change', (e) => {
            const modes = { additive: 0, alpha: 1, maximum: 2 };
            volumeMaterial.uniforms.blendMode.value = modes[e.target.value];
        });

        document.getElementById('density').addEventListener('input', (e) => {
            volumeMaterial.uniforms.density.value = parseFloat(e.target.value);
        });

        document.getElementById('stepCount').addEventListener('input', (e) => {
            volumeMaterial.uniforms.stepCount.value = parseInt(e.target.value);
        });

        document.getElementById('volumeShape').addEventListener('change', (e) => {
            currentShape = e.target.value;
            initVolume();
        });

        // Posición de la cámara
        camera.position.set(0, 0, isMobile ? 5 : 4);

        // Animación optimizada
        let lastTime = 0;
        function animate(time = 0) {
            requestAnimationFrame(animate);
            
            // Controlar velocidad de animación en dispositivos lentos
            const delta = (time - lastTime) / 1000;
            if (delta > 0.05) {
                lastTime = time;
                if (volumeMesh) {
                    volumeMesh.rotation.x += delta * 1.5;
                    volumeMesh.rotation.y += delta * 2;
                }
                volumeMaterial.uniforms.cameraPos.value = camera.position;
                renderer.render(scene, camera);
            }
        }

        // Ajuste de tamaño automático
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Iniciar todo
        initVolume();
        animate();

        // Manejar errores de WebGL
        if (!renderer.capabilities.isWebGLAvailable()) {
            document.body.innerHTML = "<div style='color:white; padding:20px; text-align:center;'>Tu dispositivo no soporta WebGL - necesitas un navegador más moderno para ver el shader.</div>";
        }
    </script>
</body>
</html>
        </div>
        <div class="control-group">
            <label for="density">Volume Density</label>
            <input type="range" id="density" min="0.1" max="1.5" step="0.1" value="0.6">
        </div>
        <div class="control-group">
            <label for="stepCount">Sampling Steps</label>
            <input type="range" id="stepCount" min="20" max="120" step="10" value="40">
        </div>
    </div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // Volume texture
        function createVolumeTexture() {
            const size = 32;
            const data = new Uint8Array(size * size * size * 4);
            for (let z = 0; z < size; z++) {
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const i = (x + y * size + z * size * size) * 4;
                        const dx = x/size - 0.5;
                        const dy = y/size - 0.5;
                        const dz = z/size - 0.5;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        const opacity = Math.max(0, 1 - dist * 2.2);
                        data[i] = 180 * (x/size);
                        data[i+1] = 220 * (y/size);
                        data[i+2] = 255 * (z/size);
                        data[i+3] = 255 * opacity;
                    }
                }
            }
            const texture = new THREE.Data3DTexture(data, size, size, size);
            texture.format = THREE.RGBAFormat;
            texture.type = THREE.UnsignedByteType;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.unpackAlignment = 1;
            texture.needsUpdate = true;
            return texture;
        }

        // Volume material
        const volumeTexture = createVolumeTexture();
        const volumeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                volumeTexture: { value: volumeTexture },
                blendMode: { value: 0 },
                density: { value: 0.6 },
                stepCount: { value: 40 },
                invSize: { value: new THREE.Vector3(1/32, 1/32, 1/32) },
                cameraPos: { value: camera.position }
            },
            vertexShader: `
                varying vec3 vPos;
                void main() {
                    vPos = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler3D volumeTexture;
                uniform int blendMode;
                uniform float density;
                uniform int stepCount;
                uniform vec3 invSize;
                uniform vec3 cameraPos;

                varying vec3 vPos;

                void main() {
                    vec3 rayOrigin = cameraPos;
                    vec3 rayDir = normalize(vPos - rayOrigin);
                    vec3 rayStep = rayDir / float(stepCount) * 2.0;
                    vec3 currPos = (vPos + 1.0) * 0.5;
                    
                    vec4 accum = vec4(0.0);

                    for (int i = 0; i < stepCount; i++) {
                        if (currPos.x < 0.0 || currPos.x > 1.0 || 
                            currPos.y < 0.0 || currPos.y > 1.0 || 
                            currPos.z < 0.0 || currPos.z > 1.0 ||
                            accum.a > 0.98) break;

                        vec4 samp = texture3D(volumeTexture, currPos);
                        samp.a *= density;

                        if (blendMode == 0) {
                            accum += samp * (1.0 - accum.a);
                        } else if (blendMode == 1) {
                            accum = mix(accum, samp, samp.a);
                        } else {
                            accum = max(accum, samp);
                        }

                        currPos += rayStep * invSize;
                    }

                    gl_FragColor = accum;
                }
            `,
            transparent: true,
            depthWrite: false
        });

        // Volume mesh
        const volumeGeo = new THREE.BoxGeometry(2, 2, 2);
        const volumeMesh = new THREE.Mesh(volumeGeo, volumeMaterial);
        scene.add(volumeMesh);

        camera.position.z = 4;

        // Controls
        document.getElementById('blendMode').addEventListener('change', (e) => {
            const modes = { additive: 0, alpha: 1, maximum: 2 };
            volumeMaterial.uniforms.blendMode.value = modes[e.target.value];
        });

        document.getElementById('density').addEventListener('input', (e) => {
            volumeMaterial.uniforms.density.value = parseFloat(e.target.value);
        });

        document.getElementById('stepCount').addEventListener('input', (e) => {
            volumeMaterial.uniforms.stepCount.value = parseInt(e.target.value);
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            volumeMesh.rotation.x += 0.004;
            volumeMesh.rotation.y += 0.008;
            volumeMaterial.uniforms.cameraPos.value = camera.position;
            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
        </div>
        <div class="control-group">
            <label for="density">Volume Density</label>
            <input type="range" id="density" min="0.1" max="1.5" step="0.1" value="0.6">
        </div>
        <div class="control-group">
            <label for="stepCount">Sampling Steps</label>
            <input type="range" id="stepCount" min="20" max="120" step="10" value="40">
        </div>
    </div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // Volume texture
        function createVolumeTexture() {
            const size = 32;
            const data = new Uint8Array(size * size * size * 4);
            for (let z = 0; z < size; z++) {
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const i = (x + y * size + z * size * size) * 4;
                        const dx = x/size - 0.5;
                        const dy = y/size - 0.5;
                        const dz = z/size - 0.5;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        const opacity = Math.max(0, 1 - dist * 2.2);
                        data[i] = 180 * (x/size);
                        data[i+1] = 220 * (y/size);
                        data[i+2] = 255 * (z/size);
                        data[i+3] = 255 * opacity;
                    }
                }
            }
            const texture = new THREE.Data3DTexture(data, size, size, size);
            texture.format = THREE.RGBAFormat;
            texture.type = THREE.UnsignedByteType;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.unpackAlignment = 1;
            texture.needsUpdate = true;
            return texture;
        }

        // Volume material
        const volumeTexture = createVolumeTexture();
        const volumeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                volumeTexture: { value: volumeTexture },
                blendMode: { value: 0 },
                density: { value: 0.6 },
                stepCount: { value: 40 },
                invSize: { value: new THREE.Vector3(1/32, 1/32, 1/32) },
                cameraPos: { value: camera.position }
            },
            vertexShader: `
                varying vec3 vPos;
                void main() {
                    vPos = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler3D volumeTexture;
                uniform int blendMode;
                uniform float density;
                uniform int stepCount;
                uniform vec3 invSize;
                uniform vec3 cameraPos;

                varying vec3 vPos;

                void main() {
                    vec3 rayOrigin = cameraPos;
                    vec3 rayDir = normalize(vPos - rayOrigin);
                    vec3 rayStep = rayDir / float(stepCount) * 2.0;
                    vec3 currPos = (vPos + 1.0) * 0.5;
                    
                    vec4 accum = vec4(0.0);

                    for (int i = 0; i < stepCount; i++) {
                        if (currPos.x < 0.0 || currPos.x > 1.0 || 
                            currPos.y < 0.0 || currPos.y > 1.0 || 
                            currPos.z < 0.0 || currPos.z > 1.0 ||
                            accum.a > 0.98) break;

                        vec4 samp = texture3D(volumeTexture, currPos);
                        samp.a *= density;

                        if (blendMode == 0) {
                            accum += samp * (1.0 - accum.a);
                        } else if (blendMode == 1) {
                            accum = mix(accum, samp, samp.a);
                        } else {
                            accum = max(accum, samp);
                        }

                        currPos += rayStep * invSize;
                    }

                    gl_FragColor = accum;
                }
            `,
            transparent: true,
            depthWrite: false
        });

        // Volume mesh
        const volumeGeo = new THREE.BoxGeometry(2, 2, 2);
        const volumeMesh = new THREE.Mesh(volumeGeo, volumeMaterial);
        scene.add(volumeMesh);

        camera.position.z = 4;

        // Controls
        document.getElementById('blendMode').addEventListener('change', (e) => {
            const modes = { additive: 0, alpha: 1, maximum: 2 };
            volumeMaterial.uniforms.blendMode.value = modes[e.target.value];
        });

        document.getElementById('density').addEventListener('input', (e) => {
            volumeMaterial.uniforms.density.value = parseFloat(e.target.value);
        });

        document.getElementById('stepCount').addEventListener('input', (e) => {
            volumeMaterial.uniforms.stepCount.value = parseInt(e.target.value);
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            volumeMesh.rotation.x += 0.004;
            volumeMesh.rotation.y += 0.008;
            volumeMaterial.uniforms.cameraPos.value = camera.position;
            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
EE.LinearFilter;
            texture.unpackAlignment = 1;
            texture.needsUpdate = true;
            return texture;
        }

        // Volume material with performance optimizations
        const volumeTexture = createVolumeTexture();
        const volumeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                volumeTexture: { value: volumeTexture },
                blendMode: { value: 0 },
                density: { value: 0.6 },
                stepCount: { value: 40 },
                invSize: { value: new THREE.Vector3(1/32, 1/32, 1/32) },
                cameraPos: { value: camera.position }
            },
            vertexShader: `
                varying vec3 vPos;
                void main() {
                    vPos = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler3D volumeTexture;
                uniform int blendMode;
                uniform float density;
                uniform int stepCount;
                uniform vec3 invSize;
                uniform vec3 cameraPos;

                varying vec3 vPos;

                void main() {
                    vec3 rayOrigin = cameraPos;
                    vec3 rayDir = normalize(vPos - rayOrigin);
                    vec3 rayStep = rayDir / float(stepCount) * 2.0;
                    vec3 currPos = (vPos + 1.0) * 0.5; // [0,1] range
                    
                    vec4 accum = vec4(0.0);

                    for (int i = 0; i < stepCount; i++) {
                        // Bounds check + early termination
                        if (currPos.x < 0.0 || currPos.x > 1.0 || 
                            currPos.y < 0.0 || currPos.y > 1.0 || 
                            currPos.z < 0.0 || currPos.z > 1.0 ||
                            accum.a > 0.98) break;

                        vec4 samp = texture3D(volumeTexture, currPos);
                        samp.a *= density;

                        // Blending modes
                        if (blendMode == 0) { // Additive
                            accum += samp * (1.0 - accum.a);
                        } else if (blendMode == 1) { // Alpha
                            accum = mix(accum, samp, samp.a);
                        } else { // Maximum
                            accum = max(accum, samp);
                        }

                        currPos += rayStep * invSize;
                    }

                    gl_FragColor = accum;
                }
            `,
            transparent: true,
            depthWrite: false
        });

        // Volume mesh
        const volumeGeo = new THREE.BoxGeometry(2, 2, 2);
        const volumeMesh = new THREE.Mesh(volumeGeo, volumeMaterial);
        scene.add(volumeMesh);

        camera.position.z = 4;

        // Controls logic
        document.getElementById('blendMode').addEventListener('change', (e) => {
            const modes = { additive: 0, alpha: 1, maximum: 2 };
            volumeMaterial.uniforms.blendMode.value = modes[e.target.value];
        });

        document.getElementById('density').addEventListener('input', (e) => {
            volumeMaterial.uniforms.density.value = parseFloat(e.target.value);
        });

        document.getElementById('stepCount').addEventListener('input', (e) => {
            volumeMaterial.uniforms.stepCount.value = parseInt(e.target.value);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            volumeMesh.rotation.x += 0.004;
            volumeMesh.rotation.y += 0.008;
            volumeMaterial.uniforms.cameraPos.value = camera.position;
            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Scene, Camera and Renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Create volume texture (simulated data)
        function createVolumeTexture(size) {
            const data = new Uint8Array(size * size * size * 4);
            for (let z = 0; z < size; z++) {
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const i = (x + y * size + z * size * size) * 4;
                        // Sphere shape inside the volume
                        const dx = x / size - 0.5;
                        const dy = y / size - 0.5;
                        const dz = z / size - 0.5;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        const val = Math.max(0, 1.0 - dist * 2.5);
                        data[i] = 255 * (0.5 + 0.5 * Math.sin(x * 5)); // Red channel
                        data[i+1] = 255 * (0.5 + 0.5 * Math.sin(y * 5)); // Green channel
                        data[i+2] = 255 * (0.5 + 0.5 * Math.sin(z * 5)); // Blue channel
                        data[i+3] = 255 * val; // Alpha (opacity) channel
                    }
                }
            }
            const texture = new THREE.Data3DTexture(data, size, size, size);
            texture.format = THREE.RGBAFormat;
            texture.type = THREE.UnsignedByteType;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.unpackAlignment = 1;
            texture.needsUpdate = true;
            return texture;
        }

        // Volume shader
        const volumeTexture = createVolumeTexture(64);
        const volumeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                volumeTexture: { value: volumeTexture },
                blendMode: { value: 0 }, // 0=additive, 1=alpha, 2=maximum
                density: { value: 0.8 },
                stepCount: { value: 80 },
                invSize: { value: new THREE.Vector3(1/64, 1/64, 1/64) },
                cameraPosition: { value: camera.position }
            },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler3D volumeTexture;
                uniform int blendMode;
                uniform float density;
                uniform int stepCount;
                uniform vec3 invSize;
                uniform vec3 cameraPosition;

                varying vec3 vPosition;

                void main() {
                    vec3 rayOrigin = cameraPosition;
                    vec3 rayDir = normalize(vPosition - rayOrigin);
                    vec3 rayStep = rayDir / float(stepCount) * 2.0;
                    vec3 currentPos = (vPosition + 1.0) * 0.5; // Convert to [0,1] range
                    
                    vec4 colorAccum = vec4(0.0);

                    for (int i = 0; i < stepCount; i++) {
                        // Stop if out of volume bounds
                        if (currentPos.x < 0.0 || currentPos.x > 1.0 || 
                            currentPos.y < 0.0 || currentPos.y > 1.0 || 
                            currentPos.z < 0.0 || currentPos.z > 1.0) break;

                        vec4 sample = texture3D(volumeTexture, currentPos);
                        sample.a *= density;

                        // Apply selected blending mode
                        if (blendMode == 0) { // Additive
                            colorAccum += sample * (1.0 - colorAccum.a);
                        } else if (blendMode == 1) { // Alpha Blend
                            colorAccum = mix(colorAccum, sample, sample.a);
                        } else if (blendMode == 2) { // Maximum
                            colorAccum = max(colorAccum, sample);
                        }

                        currentPos += rayStep * invSize;
                    }

                    gl_FragColor = colorAccum;
                }
            `,
            transparent: true,
            depthWrite: false
        });

        // Volume container geometry (cube)
        const volumeGeometry = new THREE.BoxGeometry(2, 2, 2);
        const volumeMesh = new THREE.Mesh(volumeGeometry, volumeMaterial);
        scene.add(volumeMesh);

        camera.position.z = 4;

        // Control event listeners
        document.getElementById('blendMode').addEventListener('change', (e) => {
            const modes = { additive: 0, alpha: 1, maximum: 2 };
            volumeMaterial.uniforms.blendMode.value = modes[e.target.value];
        });

        document.getElementById('density').addEventListener('input', (e) => {
            volumeMaterial.uniforms.density.value = parseFloat(e.target.value);
        });

        document.getElementById('stepCount').addEventListener('input', (e) => {
            volumeMaterial.uniforms.stepCount.value = parseInt(e.target.value);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            volumeMesh.rotation.x += 0.005;
            volumeMesh.rotation.y += 0.01;
            volumeMaterial.uniforms.cameraPosition.value = camera.position;
            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
            texture.type = THREE.UnsignedByteType;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.unpackAlignment = 1;
            texture.needsUpdate = true;
            return texture;
        }

        // Shader de volumen
        const volumeTexture = createVolumeTexture(64);
        const volumeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                volumeTexture: { value: volumeTexture },
                blendMode: { value: 0 }, // 0=aditivo, 1=alpha, 2=máximo
                density: { value: 0.8 },
                stepCount: { value: 80 },
                invSize: { value: new THREE.Vector3(1/64, 1/64, 1/64) },
                cameraPosition: { value: camera.position }
            },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler3D volumeTexture;
                uniform int blendMode;
                uniform float density;
                uniform int stepCount;
                uniform vec3 invSize;
                uniform vec3 cameraPosition;

                varying vec3 vPosition;

                void main() {
                    vec3 rayOrigin = cameraPosition;
                    vec3 rayDir = normalize(vPosition - rayOrigin);
                    vec3 rayStep = rayDir / float(stepCount) * 2.0;
                    vec3 currentPos = (vPosition + 1.0) * 0.5; // Convertir a [0,1]
                    
                    vec4 colorAccum = vec4(0.0);

                    for (int i = 0; i < stepCount; i++) {
                        if (currentPos.x < 0.0 || currentPos.x > 1.0 || 
                            currentPos.y < 0.0 || currentPos.y > 1.0 || 
                            currentPos.z < 0.0 || currentPos.z > 1.0) break;

                        vec4 sample = texture3D(volumeTexture, currentPos);
                        sample.a *= density;

                        if (blendMode == 0) { // Aditivo
                            colorAccum += sample * (1.0 - colorAccum.a);
                        } else if (blendMode == 1) { // Alpha Blend
                            colorAccum = mix(colorAccum, sample, sample.a);
                        } else if (blendMode == 2) { // Máximo
                            colorAccum = max(colorAccum, sample);
                        }

                        currentPos += rayStep * invSize;
                    }

                    gl_FragColor = colorAccum;
                }
            `,
            transparent: true,
            depthWrite: false
        });

        // Geometría del volumen (cubo contenedor)
        const volumeGeometry = new THREE.BoxGeometry(2, 2, 2);
        const volumeMesh = new THREE.Mesh(volumeGeometry, volumeMaterial);
        scene.add(volumeMesh);

        camera.position.z = 4;

        // Controles
        document.getElementById('blendMode').addEventListener('change', (e) => {
            const modes = { additive: 0, alpha: 1, maximum: 2 };
            volumeMaterial.uniforms.blendMode.value = modes[e.target.value];
        });

        document.getElementById('density').addEventListener('input', (e) => {
            volumeMaterial.uniforms.density.value = parseFloat(e.target.value);
        });

        document.getElementById('stepCount').addEventListener('input', (e) => {
            volumeMaterial.uniforms.stepCount.value = parseInt(e.target.value);
        });

        // Animación
        function animate() {
            requestAnimationFrame(animate);
            volumeMesh.rotation.x += 0.005;
            volumeMesh.rotation.y += 0.01;
            volumeMaterial.uniforms.cameraPosition.value = camera.position;
            renderer.render(scene, camera);
        }
        animate();

        // Ajustar tamaño con ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
